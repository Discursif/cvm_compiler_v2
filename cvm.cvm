use std;

fn merge(Bytes a, Bytes b) -> Bytes {
    asm {
        MERGE Bytes out, a, b;
    }
    return out
}
fn add(Bytes a, Bytes b) -> Bytes {
    asm {
        ADD Bytes out, a, b;
    }
    return out
}
fn sub(Bytes a, Bytes b) -> Bytes {
    asm {
        SUB Bytes out, a, b;
    }
    return out
}
fn mul(Bytes a, Bytes b) -> Bytes {
    asm {
        MUL Bytes out, a, b;
    }
    return out
}
fn div(Bytes a, Bytes b) -> Bytes {
    asm {
        DIV Bytes out, a, b;
    }
    return out
}
fn xor(Bytes a, Bytes b) -> Bytes {
    asm {
        XOR Bytes out, a, b;
    }
    return out
}
fn read(Bytes a, Byte b, Byte c) -> Bytes {
    asm {
        READ Bytes out, a, b, c;
    }
    return out
}
fn len(Bytes a) -> Bytes {
    asm {
        LEN Bytes out, a;
    }
    return out
}
fn print(Bytes a) {
    asm {
        PRINT a;
    }
}
fn input(Bytes a) {
    asm {
        INPUT a;
    }
}

type Bytes {
    fn add(Bytes other) -> Bytes => return add(self,other) as Bytes;
    fn sub(Bytes other) -> Bytes => return sub(self,other) as Bytes;
    fn mul(Bytes other) -> Bytes => return mul(self,other) as Bytes;
    fn div(Bytes other) -> Bytes => return div(self,other) as Bytes;
    fn xor(Bytes other) -> Bytes => return xor(self,other) as Bytes;
    fn index(Byte position) -> Byte => return read(self,position,1) as Byte;
    fn index_range(Byte position1,Byte position2) -> Bytes => return read(self,position1,position2-position1);
    fn len() -> Byte => return len(self) as Byte;
    fn merge(Bytes other) -> Bytes => return merge(self,other) as Bytes;
}

type Empty = 0 {
    fn len() -> Byte => return 0;
}
type Byte = 1 {
    fn add(Bytes other) -> Byte => return super.add(other) as Byte;
    fn sub(Bytes other) -> Byte => return super.sub(other) as Byte;
    fn mul(Bytes other) -> Byte => return super.mul(other) as Byte;
    fn div(Bytes other) -> Byte => return super.div(other) as Byte;
    fn xor(Bytes other) -> Byte => return super.xor(other) as Byte;
    fn index(Byte position) -> Panic {}
    fn index_range(Byte position1,Byte position2) -> Panic {}
    fn len() -> Byte => return 1;
}
type Char: Byte = 1 {
    fn add(Bytes other) -> Char => return super.add(other) as Char;
    fn sub(Bytes other) -> Char => return super.sub(other) as Char;
    fn mul(Bytes other) -> Char => return super.mul(other) as Char;
    fn div(Bytes other) -> Char => return super.div(other) as Char;
    fn xor(Bytes other) -> Char => return super.xor(other) as Char;
    fn merge(Char other) -> String => return super.merge(other) as String;
    fn merge(String other) -> String => return super.merge(other) as String;
}

type Boolean = 1 {
    ref true = 1;
    ref false = 0;

    fn to_string() -> String {
        if self => return "true" as String;
        return "false" as String;
    }

    fn merge(Bytes other) -> Panic {}

    fn len() -> Byte => return 1;
}

type String {
    fn join(String a) -> String {
        return self ~ " " ~ a;
    }
    
    fn index(Byte position) -> Char => return super.index(position) as Char;
    fn index_range(Byte position1,Byte position2) -> String => return super.index_range(position1,position2) as String;
    fn merge(String other) -> String => return super.merge(other) as String;
    fn merge(Char other) -> String => return super.merge(other) as String;

    static fn new(Bytes bytes) -> String {
        return bytes as String;
    }
}

fn main() {
    Byte a = "a";
    loop {
        if a == "f" {
            break;
        }
        a += 1;
        if a == "c" => continue;
    }
    print(a);
    for Byte i in "a".."f" {
        print(i)
    }
    for Byte ix in "abcde" {
        print("abcde")
    }
    String a = "test";
    for Byte i in 0..26 {
        a ~= "a" + i
    }
    print(a ~ "test")
    for Byte i in "a".."z" {
        print(i)
    }
    if "test" == "test" {
        print("a");
    }
    String a = "test" ~ 10 as String;
    print(a.join("malou"[3..5] as String));
}